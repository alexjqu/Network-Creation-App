<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Creation App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #app {
            text-align: center;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid gray;
            border-radius: 3px;
        }
        #canvas-container {
            margin-top: 20px;
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <div id="app">
        <div>
            <button id="createBtn">Create</button>
            <button id="dragBtn">Drag</button>
            <button id="deleteBtn">Delete</button>
            <button id="clearBtn">Clear</button>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script>
        let nodes = {};
        let network = {};
        let graphs = {};
        let activeButton = null;
        let highlightedNode = null;
        let nodeCount = 0;
        let draggedNode = null;

        const radius = 20;
        const color = '#646464';
        const highlightColor = '#ff0000';

        // The setup() function is a part of the p5.js library
        // When the sketch starts running, the setup() function is called once
        function setup() {
            let canvas = createCanvas(600, 600);
            canvas.parent('canvas-container');
            background(255);

            select('#createBtn').mousePressed(() => setActiveButton('create'));
            select('#dragBtn').mousePressed(() => setActiveButton('drag'));
            select('#deleteBtn').mousePressed(() => setActiveButton('delete'));
            select('#clearBtn').mousePressed(clearAllNodes);
        }
        // The draw() function is also a part of the p5.js library
        // While the sketch runs, the draw() function is called repeatedly
        function draw() {
            background(255);
            drawNetwork();
        }

        // Draws the whole network including nodes and the arrows
        function drawNetwork() {
            stroke(0);
            strokeWeight(2);
            Object.entries(network).forEach(([fromNode, toNodes]) => {
                toNodes.forEach(toNode => {
                    drawArrow(nodes[fromNode].pos, nodes[toNode].pos);
                });
            });

            noStroke();
            Object.entries(nodes).forEach(([nodeId, data]) => {
                fill(data.highlighted ? highlightColor : color);
                ellipse(data.pos.x, data.pos.y, radius * 2);
                fill(color)
            });
        }

        // Draws arrows
        function drawArrow(start, end) {
            let angle = atan2(end.y - start.y, end.x - start.x);
            let distance = dist(start.x, start.y, end.x, end.y);
            
            push();
            translate(start.x, start.y);
            rotate(angle);
            line(0, 0, distance - radius, 0);
            
            let arrowSize = 10;
            translate(distance - radius - arrowSize, 0);
            triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
            pop();
        }

        // Check if mouse button is pressed
        // Part of the p5.js library
        function mousePressed() {
            const pos = { x: mouseX, y: mouseY };
            if (activeButton === 'create' && mouseButton == 'left') {
                if (!connectNode(pos)) {
                    if (withinCanvas(pos) && !isOverlapping(pos)) {
                        createNode(pos);
                        console.log(nodes)
                    }
                }
            } else {
                if (activeButton === 'delete' && mouseButton == 'left') {
                    if (withinCanvas(pos) && isOverlapping(pos)) {

                    }
                }
            }
        }

        function mouseDragged() {
            if (activeButton === 'drag') {
                const pos = { x: mouseX, y: mouseY };
                if (!draggedNode) {
                    draggedNode = Object.entries(nodes).find(([_, data]) => 
                        dist(pos.x, pos.y, data.pos.x, data.pos.y) <= radius
                    );
                }
                if (draggedNode) {
                    const [nodeId, _] = draggedNode;
                    const newPos = {
                        x: constrain(pos.x, radius, width - radius),
                        y: constrain(pos.y, radius, height - radius)
                    };
                    if (!isOverlappingExcept(newPos, nodeId)) {
                        nodes[nodeId].pos = newPos;
                    }
                }
            }
        }

        function mouseReleased() {
            draggedNode = null;
        }

        function withinCanvas(pos) {
            return pos.x >= radius && pos.x <= width - radius && pos.y >= radius && pos.y <= height - radius;
        }

        function isOverlapping(pos) {
            return Object.values(nodes).some(node => 
                dist(pos.x, pos.y, node.pos.x, node.pos.y) <= radius * 2
            );
        }

        function createNode(pos) {
            const name = `node${nodeCount + 1}`;
            const nodeId = nodeCount + 1;
            nodes[nodeId] = { name, pos, highlighted: false };
            network[nodeId] = [];
            nodeCount++;
        }

        function connectNode(pos) {
            const clickedNode = Object.entries(nodes).find(([_, data]) => 
                dist(pos.x, pos.y, data.pos.x, data.pos.y) <= radius
            );

            if (clickedNode) {
                const [nodeId, _] = clickedNode;
                if (highlightedNode === null) {
                    highlightedNode = nodeId;
                    nodes[nodeId].highlighted = true;
                } else {
                    if (highlightedNode !== nodeId) {
                        network[highlightedNode].push(nodeId);
                    }
                    nodes[highlightedNode].highlighted = false;
                    highlightedNode = null;
                }
                return true;
            }
            return false;
        }

        function isOverlappingExcept(pos, exceptNodeId) {
            return Object.entries(nodes).some(([nodeId, node]) => 
                nodeId !== exceptNodeId && dist(pos.x, pos.y, node.pos.x, node.pos.y) <= radius * 2
            );
        }

        function clearAllNodes() {
            nodes = {};
            network = {};
            nodeCount = 0;
            highlightedNode = null;
        }

        function setActiveButton(button) {
            activeButton = button;
            select('#createBtn').style('background-color', button === 'create' ? '#ddd' : '#fff');
            select('#dragBtn').style('background-color', button === 'drag' ? '#ddd' : '#fff');
            select('#deleteBtn').style('background-color', button === 'delete' ? '#ddd' : '#fff');
        }
    </script>
</body>
</html>